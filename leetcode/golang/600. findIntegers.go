package leetcode

func findIntegers(n int) int {
	// 转态转移方程： dp[i] = dp[i - 1] + dp[i - 2]
	// dp[n]定义为从低位往高位数，前n个二进制位，所能产生的合法数字的个数。不出现连续的“1”就是合法数字。

	// 例如dp[2] = 3。三个合法数字分别为00，01，10。11由于有连续的1，不合法。

	// 给定任意一个i，i小于等于31，如何计算确定dp[i]呢？
	//
	// dp[i]中的合法数字可以从dp[i-1]和dp[i-2]中得到：
	//
	// 1. 从dp[i-1]中得到：只需要在长度为i-1的合法数字的高位补充一个“0”。补充完以后的数字一定合法。
	//
	// 2. 从dp[i-2]中得到：只需要在长度为i-2的合法数字的高位补充一个“10”。补充完以后的数字一定合法。
	//
	// 所以dp[i]就等于dp[i-1]加上dp[i-2]。
	//
	// 即dp[i] = dp[i - 1] + dp[i - 2]。 初始状态为dp[0] = dp[1] = 1
	dp := make([]int, 32)
	dp[0] = 1
	dp [1] = 1
	for i:= 2; i <= 31; i++ {
		dp[i] = dp[i-2] + dp[i-1]
	}
	// pre 记录上一层的根节点值，res 记录最终路径数
	pre := 0
	res := 0
	for i := 29; i >= 0; i-- {
		// val: 10{29 ~ 0}
		val := 1 << uint(i)
		// if 语句判断 当前子树是否有右子树
		if (n & val) != 0 {
			// 有右子树
			n -= val
			res += dp[i + 1] // 先将左子树（满二叉树）的路径加到结果中
			// 处理右子树
			if pre == 1 {
				// 上一层为 1，之后要处理的右子树根节点肯定也为 1
				// 此时连续两个 1，不满足题意，直接退出
				break
			}
			// 标记当前根节点为 1
			pre = 1
		} else {
			// 无右子树，此时不能保证左子树是否为满二叉树，所以要在下一层再继续判断
			pre = 0
		}
		// 其实就是加上最后一个0的可能性
		if i == 0 {
			res++
		}
	}
	return res
}